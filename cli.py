#!/usr/bin/env python3
import yaml
import click
import keyring
import ipaddress
import networkx as nx

from sys import exit
from copy import copy
from tqdm import tqdm

from pyopnsense import firewall_alias

service_name = "opnsense_alias_updater"


class Firewall(object):
    def __init__(self, config):
        key = config["key"]
        private = keyring.get_password(service_name, key)
        self.client = firewall_alias.FirewallAliasClient(
            key, private, config["base_url"], verify_cert=True
        )

    def get_uuid(self, name):
        for row in self.client.search_item(name)["rows"]:
            if row["name"] == name:
                return row["uuid"]
        return None

    def save(self, alias_data):
        data = copy(alias_data)
        data["description"] = "[{}] {}".format(
            service_name,
            data.get("description", "")
        )

        uuid = self.get_uuid(data["name"])

        if uuid is not None:
            data["id"] = uuid
            result = self.client.set_item(**data)
        else:
            result = self.client.add_item(**data)

        if result.get("result") != "saved":
            raise ValueError(result.get('validations'))

    def get_items_generated_by_updater(self):
        last_page = False
        rowCount = 100
        current = 1
        items = list()

        pattern = "[%s]" % service_name
        pattern_lenght = len(pattern)

        while not last_page:
            rows = self.client.search_item(
                current=current, rowCount=rowCount
            )['rows']

            if len(rows) == rowCount:
                current = current + 1
            else:
                last_page = True

            for row in rows:
                if row["description"][:pattern_lenght] == pattern:
                    items.append(row)
        return items

    def delete(self, uuid):
        self.client.delete_item(uuid)

    def apply(self):
        self.client.reconfigure()


class NetworkFile(object):
    _path = "networks.yml"

    def __init__(self):
        with open(self._path, 'r') as stream:
            try:
                self.data = yaml.safe_load(stream)
            except yaml.YAMLError as exc:
                print(exc)
                exit(-1)

    @staticmethod
    def contains_exclusively_ip_CIDR(alias):
        for content in alias["content"]:
            try:
                ipaddress.ip_address(content)
                continue
            except ValueError:
                pass
            try:
                ipaddress.ip_network(content)
                continue
            except ValueError:
                pass
            return False
        return True

    @staticmethod
    def is_dependency(content):
        if "http://" == content[:7] or "https://" == content[:8]:
            return False
        try:
            ipaddress.ip_address(content)
            return False
        except ValueError:
            pass
        try:
            ipaddress.ip_network(content)
            return False
        except ValueError:
            pass
        return True

    def save(self):
        with open(self._path, 'w') as stream:
            yaml.dump(self.data, stream)

    def sort(self):
        G = nx.DiGraph()

        for alias in self.data["networks"]:
            for dep in alias["content"]:
                if self.is_dependency(dep):
                    G.add_edge(alias["name"], dep)

        sorted_networks = list(reversed(list(nx.topological_sort(G))))
        self.data["networks"] = sorted(
                self.data["networks"],
                key=lambda k: (
                    sorted_networks.index(k['name'])
                    if k['name'] in sorted_networks else 0
                )
            )


@click.group()
def cli():
    global network_file
    network_file = NetworkFile()


@cli.command(help='Push autogenerated aliases on firewall and apply them.')
def push():
    for fw_config in network_file.data["firewalls"]:
        fw = Firewall(fw_config)
        click.echo('Pushing autogenerated aliases on %s' % fw_config["name"])
        for alias in tqdm(network_file.data["networks"]):
            fw.save(alias)
        fw.apply()
        click.echo('Aliases applyied on %s' % fw_config["name"])


@cli.command(help='Remove unreferenced autogenerated aliases.')
def clean():
    alias_names = map(lambda x: x["name"], network_file.data["networks"])
    for fw_config in network_file.data["firewalls"]:
        fw = Firewall(fw_config)
        click.echo('Cleaning autogenerated aliases on %s' % fw_config["name"])

        click.echo('Filtering ...')
        delete_list = list()
        for row in tqdm(fw.get_items_generated_by_updater()):
            if row["name"] not in alias_names:
                delete_list.append(row['uuid'])

        click.echo('Deleting ...')
        for uuid in tqdm(delete_list):
            fw.delete(uuid)


@cli.command(help='Sort network file.')
def sort():
    network_file.sort()
    network_file.save()


if __name__ == "__main__":
    cli()
